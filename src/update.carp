(defn update-player-position [player]
  (with Key
    (with Player
      (match-ref (state &player)
        PlayerState.Jumping (update-y player &(fn [y] (- y 2)))
        PlayerState.Falling (update-y player &(fn [y] (+ y 2)))
        _                   player))))

(defn update-player-state [player]
  (with Key
    (with Player
      (match-ref (state &player)
        (PlayerState.Running _) (if (is-down? A)
                                 (set-state player (PlayerState.Jumping))
                                 (tick player))
        PlayerState.Jumping     (if (<= (y &player) &(- floor-y 75))
                                 (set-state player (PlayerState.Falling))
                                 player)
        PlayerState.Falling     (if (>= (y &player) &(- floor-y (height)))
                                 (set-state player (PlayerState.Running 1))
                                 player)))))

(defn update-obstacle-position [obstacle]
  (Obstacle.update-x
   obstacle
   &(fn [x] (if (<= x 0)
              (+ (Rand.range 50 Video.screen-width) Video.screen-width)
              (- x 2)))))

(defn update-obstacles-position [obstacles]
  (Array.endo-map
   &update-obstacle-position
   obstacles))

(defn update-position [world]
  (match-ref (World.state &world)
    WorldState.Playing
    (=> world
        (World.update-p &update-player-position)
        (World.update-obstacles &update-obstacles-position))

    _ world))

(defn update-world-state [world]
  (if (Key.hit? Key.Start)
      (match-ref (World.state &world)
         WorldState.Playing       (World.set-state world (WorldState.Paused))
         WorldState.Dead          (World.new)
         (WorldState.Intro tik)   (do (Rand.set-seed @tik) (World.set-state world (WorldState.Playing)))
         _                        (World.set-state world (WorldState.Playing)))
      (World.tick world)))

(defn check-for-collisions [world]
  (let [world* &world]
   (World.update-state world
    &(fn [state]
      (if (Array.any?
           &(fn [obs] (rect-colliding? (World.p world*)
                                       obs))
           (World.obstacles world*))
        (WorldState.Dead)
        (WorldState.Playing))))))

(defn update-back-zero [x] (inc x))
(defn update-back-one [x] (inc (inc x)))

(defn update-state-if-playing [world]
  (match-ref (World.state &world)
     WorldState.Playing
     (=> world
         (World.update-p &update-player-state)
         (World.update-back-zero-x &update-back-zero)
         (World.update-back-one-x &update-back-one)
         (check-for-collisions))
     _ world))

(defn update-state [world]
  (=> world
      (update-world-state)
      (update-state-if-playing)))

(sig update (Fn [World] World))
(defn update [world]
  (=> world
    (update-position)
    (update-state)))

